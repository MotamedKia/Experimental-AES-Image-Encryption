<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AES Image Encryptor (Demo)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;display:flex;flex-direction:column;gap:12px;align-items:center;padding:18px}
    .row{display:flex;gap:12px;align-items:center}
    canvas{border:1px solid #ccc;max-width:320px}
    textarea{width:640px;height:120px}
    label{font-weight:600}
    .controls{display:flex;flex-direction:column;gap:8px}
    input[type=file]{padding:6px}
    button{padding:8px 12px;border-radius:6px;border:1px solid #888;background:#f3f3f3}
    .small{font-size:12px;color:#666}
  </style>
</head>
<body>
  <h2>AES Image Encryptor — Demo (client-side)</h2>
  <div class="controls">
    <label>Choose image (PNG or JPEG): <input id="file" type="file" accept="image/*"></label>
    <label>Password (used to derive AES key): <input id="password" type="password" value="password123"></label>
    <div class="row">
      <button id="encrypt">Encrypt (show ciphertext image)</button>
      <button id="decrypt" disabled>Decrypt (restore)</button>
      <button id="download" disabled>Download ciphertext (binary)</button>
    </div>
    <div class="small">This demo derives an AES‑GCM key from the password (PBKDF2). All work is done in the browser; keys and blobs stay local.</div>
  </div>  <div class="row">
    <div>
      <div style="text-align:center"><strong>Plaintext (original)</strong></div>
      <canvas id="plain" width="320" height="240"></canvas>
    </div>
    <div>
      <div style="text-align:center"><strong>Ciphertext (visualized noise)</strong></div>
      <canvas id="cipher" width="320" height="240"></canvas>
    </div>
  </div>  <div>
    <div style="font-weight:600">Ciphertext (Base64, includes salt+iv+cipher):</div>
    <textarea id="out" readonly></textarea>
  </div>  <script>
    // Utility helpers
    const fileInput = document.getElementById('file');
    const passwordInput = document.getElementById('password');
    const plainCanvas = document.getElementById('plain');
    const cipherCanvas = document.getElementById('cipher');
    const encryptBtn = document.getElementById('encrypt');
    const decryptBtn = document.getElementById('decrypt');
    const downloadBtn = document.getElementById('download');
    const out = document.getElementById('out');

    let originalImageData = null; // Uint8ClampedArray
    let saved = null; // object to keep salt, iv, ciphertext (ArrayBuffer)

    function readImageFile(file){
      return new Promise((res,rej)=>{
        const img = new Image();
        img.onload = ()=>{
          const ctx = plainCanvas.getContext('2d');
          // fit canvas to image (keeping max 320 width)
          const maxW = 320; const scale = Math.min(1, maxW / img.width);
          plainCanvas.width = Math.round(img.width * scale);
          plainCanvas.height = Math.round(img.height * scale);
          cipherCanvas.width = plainCanvas.width;
          cipherCanvas.height = plainCanvas.height;
          ctx.clearRect(0,0,plainCanvas.width,plainCanvas.height);
          ctx.drawImage(img,0,0,plainCanvas.width,plainCanvas.height);
          const id = ctx.getImageData(0,0,plainCanvas.width,plainCanvas.height);
          originalImageData = id.data.slice();
          res(id);
        };
        img.onerror = rej;
        const reader = new FileReader();
        reader.onload = ()=>{ img.src = reader.result; };
        reader.readAsDataURL(file);
      });
    }

    async function deriveKeyFromPassword(password, salt){
      const enc = new TextEncoder();
      const pwKey = await crypto.subtle.importKey('raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']);
      const key = await crypto.subtle.deriveKey(
        {name:'PBKDF2', salt, iterations: 250000, hash: 'SHA-256'},
        pwKey,
        {name:'AES-GCM', length: 256},
        false,
        ['encrypt','decrypt']
      );
      return key;
    }

    function abToBase64(ab){
      const bytes = new Uint8Array(ab);
      let binary = '';
      const chunk = 0x8000;
      for (let i=0; i<bytes.length; i+=chunk){
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
      }
      return btoa(binary);
    }
    function base64ToAb(b64){
      const binary = atob(b64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i=0;i<len;i++) bytes[i]=binary.charCodeAt(i);
      return bytes.buffer;
    }

    fileInput.addEventListener('change', async (e)=>{
      const file = e.target.files?.[0];
      if (!file) return;
      await readImageFile(file);
      // draw plain already done
      out.value = '';
      decryptBtn.disabled = true;
      downloadBtn.disabled = true;
    });

    encryptBtn.addEventListener('click', async ()=>{
      if (!originalImageData) return alert('Load an image first');
      const password = passwordInput.value || '';
      // salt and iv
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKeyFromPassword(password, salt.buffer);
      const plaintext = new Uint8Array(originalImageData.buffer); // RGBA bytes

      // AES-GCM encrypt
      const ciphertext = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, plaintext);
      // Save everything needed to decrypt
      saved = {salt: salt.buffer, iv: iv.buffer, ciphertext};

      // Visualize ciphertext: we will take the ciphertext bytes and map into pixel buffer
      const cipherBytes = new Uint8Array(ciphertext);
      const renderLen = plaintext.length; // need this many bytes for pixels
      // if cipher shorter (unlikely), pad with zeros
      const renderBuf = new Uint8ClampedArray(renderLen);
      for (let i=0;i<renderLen;i++) renderBuf[i] = cipherBytes[i % cipherBytes.length];

      // Put into canvas
      const ctx = cipherCanvas.getContext('2d');
      const imageData = new ImageData(renderBuf, cipherCanvas.width, cipherCanvas.height);
      ctx.putImageData(imageData, 0, 0);

      // Output base64 package: salt||iv||cipher
      const combined = new Uint8Array(salt.byteLength + iv.byteLength + ciphertext.byteLength);
      combined.set(new Uint8Array(salt), 0);
      combined.set(new Uint8Array(iv), salt.byteLength);
      combined.set(new Uint8Array(ciphertext), salt.byteLength + iv.byteLength);
      out.value = abToBase64(combined.buffer);

      decryptBtn.disabled = false;
      downloadBtn.disabled = false;
    });

    decryptBtn.addEventListener('click', async ()=>{
      if (!saved) return alert('Nothing to decrypt');
      const password = passwordInput.value || '';
      const key = await deriveKeyFromPassword(password, saved.salt);
      try{
        const plainBuf = await crypto.subtle.decrypt({name:'AES-GCM', iv: saved.iv}, key, saved.ciphertext);
        // draw restored image to plain canvas
        const ctx = plainCanvas.getContext('2d');
        const id = ctx.getImageData(0,0,plainCanvas.width,plainCanvas.height);
        id.data.set(new Uint8ClampedArray(plainBuf));
        ctx.putImageData(id,0,0);
        alert('Decryption successful — original image restored in left canvas');
      }catch(err){
        alert('Decryption failed: ' + err.message);
      }
    });

    downloadBtn.addEventListener('click', ()=>{
      if (!out.value) return;
      const blob = new Blob([base64ToAb(out.value)], {type:'application/octet-stream'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'image_cipher.bin';
      a.click();
      URL.revokeObjectURL(url);
    });

  </script></body>
</html>
